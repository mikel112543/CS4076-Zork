#include<iostream>
#include<map>
#include <utility>
#include<vector>
#include<string>
#include<sstream>
#include<ctime>
#include <algorithm>
#include <random>
#include <chrono>

using namespace std;

/** Converts strings from UPPERCASE or MiXedCasE to lowercase. */
string tolower(string &s) {
    string ns;
    for (auto c : s) {
        ns += tolower(c);
    }
    return ns;
}

// EventListener.h
/** Parent class of all listeners. (It is abstract and can't be instantiated) */
class EventListener {
public:
    // "void *" is a generic pointer to anything!
    // 10x worse than regular pointers in potential problems
    virtual void run(void *args) = 0;
};

// EventManager.h (Implemented as a Singleton)
/** This class manages the event loop and all the event calls */
struct EventManager // Structs in C++ are the same as classes, but default to "public" instead of "private".
{
    // static inside a class or struct works exactly like in java
    // Only one instance per class.
    static EventManager &getInstance(); // Gets an instance of the class (an object)

    // Making sure I can't have copies of this instance.
    EventManager(EventManager const &copy);            // Not Implemented (Copy constructor)
    EventManager &operator=(EventManager const &copy); // Not Implemented (Assignment operator)

    // Registers an event.
    void listen(string event_name, EventListener *listener);

    // Emits an event
    // "void *" is a generic pointer to anything.
    // !!! Highly unsafe, please don't do this at home without the presence of your parents !!!
    void trigger(string event_name, void *args = nullptr);

    // Returns true if still running
    bool is_running();

    // Stops the event loop
    void stop();

    // Reads the input and calls an input event
    void check_events();

    // constantly checks for new inputs until the program ends.
    void event_loop();

private:
    // True if running
    bool running;

    // map<K, V> is a collection of V's indexed by S.
    // In this case, we have lists/vectors of events indexed by their names.
    map<string, vector<EventListener *>> registeredEvents;

    // Only EventManager can call the constructor, so the only way to get an instance
    // is by calling getInstance.
    EventManager();
};

// InputListener.h
class Game; // I'm repeating this line, to pretent it is in a different file.

// A listener that gets called when a new input is received.
struct InputListener : EventListener // Structs default to public even in inheritance.
{
    InputListener(Game *game);

    void run(void *args) override;

private:
    // We store a game pointer for easy access.
    Game *game;
    vector<string> args;
};

// GoListener.h
class Game;

// A listener for the Go command
class GoListener : public EventListener {
public:
    GoListener(Game *game);

    void run(void *args) override;

private:
    Game *game;
    string direction;
};

// TeleportListener.h
class Game;

// A listener for the Teleport command
class TeleportListener : public EventListener {
public:
    TeleportListener(Game *game);

    void run(void *args) override;

private:
    Game *game;
};

// EnterRoomListener.h
class Game;

// A listener for the good ending
class EnterRoomListener : public EventListener {
public:
    EnterRoomListener(Game *game);

    void run(void *args) override;

private:
    Game *game;
};

// CharacterDeathListener.h
class Game;

// A listener for the bad ending
class CharacterDeathListener : public EventListener {
public:
    CharacterDeathListener(Game *game);

    void run(void *args) override;

private:
    Game *game;
};

// EnemyDeathListener.h
class Game;


class EnemyDeathListener : public EventListener {
public:
    EnemyDeathListener(Game *game);

    void run(void *args) override;

private:
    Game *game;
};

// ResetListener.h
class Game;

// A listener for the good ending
class RestartListener : public EventListener {
public:
    RestartListener(Game *game);

    void run(void *args) override;

private:
    Game *game;
};

// VictoryListener.h
class Game;

// A listener for the good ending
class VictoryListener : public EventListener {
public:
    VictoryListener(Game *game);

    void run(void *args) override;

private:
    Game *game;
};

// DefeatListener.h
class Game;

// A listener for the bad ending
class DefeatListener : public EventListener {
public:
    DefeatListener(Game *game);

    void run(void *args) override;

private:
    Game *game;
};

// ExitListener.h
class Game;

// A listener for the exit command
class ExitListener : public EventListener {
public:
    ExitListener(Game *game);

    void run(void *args) override;

private:
    Game *game;
};

// MapListener.h
class Game;

// A listener for the exit command
class MapListener : public EventListener {
public:
    MapListener(Game *game);

    void run(void *args) override;

private:
    Game *game;
};

// InfoListener.h
class Game;

// A listener for the exit command
class InfoListener : public EventListener {
public:
    InfoListener(Game *game);

    void run(void *args) override;

private:
    Game *game;
};

// AttackListener.h
class Game;

class AttackListener : public EventListener {

public:
    AttackListener(Game *game);

    void run(void *args) override;

private:
    Game *game;
};

// ShowListener.h
class Game;

class ShowListener : public EventListener {

public:
    ShowListener(Game *game);

    void run(void *args) override;

private:
    Game *game;
};

// TakeListener.h
class Game;

class TakeListener : public EventListener {

public:
    TakeListener(Game *game);

    void run(void *args) override;

private:
    Game *game;

};

// DamageListener.h
class Game;

class DamageListener : public EventListener {
public:
    DamageListener(Game *game);

    void run(void *args) override;

private:
    Game *game;
};

// Item.h
class Item {

public:
    Item(string name, string description, int value);

    /********
     * 7. Virtual functions & Polymorphism
     */
    virtual ~Item();

    virtual string getDescription();

    string getName();

    int getValue() const;

protected:
    string description;

private:
    string name;
    int value;
};

class Weapon : public Item {

public:
    Weapon(string name, string description, int value);

    string getDescription() override;

    ~Weapon() override;

private:
};

// Room.h
class Item;

class Room {
public:
    friend class Player;

    Room(string name);

    Room(string name, bool isLocked);

    string getName();

    void setExits(Room *north, Room *east, Room *south, Room *west);

    Room *getExit(string direction);

    void addItem(Item *newItem);

    void removeItem(string itemName);

    void setName(string name);

    string displayItem();

    Item* getItem(string itemName);

    bool isItemInRoom(string itemName);

    bool lockCheck();

    bool unlock();

private:
    string name;
    bool isLocked;
    map<string, Room *> exits;
    vector<Item *> itemsInRoom;

};

// Character.h
class Character {

public:
    Character(string _name, int _health, int _stamina);

    /**********
     * 7. Virtual functions and polymorphism
     */
    virtual ~Character();

    string getName() const;

    int getHealth() const;

    int getStamina() const;

    Room *getCurrentRoom();

    /***********
     * 8. Abstract classes and pure virtual functions
     * Character is abstract class
     * @param _health
     */
    virtual void setHealth(int _health) = 0;

    virtual void setStamina(int _stamina) = 0;

    void setCurrentRoom(Room *next);

    friend ostream &operator<<(ostream &os, const Character &character);

    void operator-(int _health);

    void operator+(int _health);

private:
    string name;

protected:
    int health;
    int stamina;
    Room *currentRoom;
};

class Player : public Character {

public:
    Player(const string &name);

    ~Player() override;

    string displayInventory();

    void addToInventory(const string &itemName);

    void removeFromInventory(const string &itemName);

    bool itemInInventory(const string &itemName);

    Item* getInventoryItem(const string &itemName);

    virtual void setHealth(int _health) override;

    virtual void setStamina(int _stamina) override;

private:
    vector<Item *> Inventory;
};

class Enemy : public Character {

public:
    Enemy(const string &name, int health, int stamina, bool _roaming);

    ~Enemy() override;

    bool roamingCheck() const;

    void Move(Enemy *enemy);

    virtual void setHealth(int _health) override;

    virtual void setStamina(int _stamina) override;

private:
    bool roaming;
};

// Game.h
class Game {
public:
    Game();

    void reset(bool show_update = true);

    void map();

    void mapUpdate();

    void info();

    void go(string direction);

    void teleport();

    void take(const string& itemName);

    void attack(const string &enemyName);

    void removeEnemy(const string &enemyName);

    void show(const string &objects);

    template<class obj>
    string printVector(vector<obj> vec);

    void update_screen();

    Player &getPlayer();

    void setOver(bool over);

    bool is_over();

private:
    vector<Room *> rooms;
    vector<Enemy *> enemies;
    Player player;
    vector<Character *> bosses;
    bool gameOver;

};

// EventManager.cpp
EventManager::EventManager() {
    running = true;
}

EventManager &EventManager::getInstance() {
    // static inside functions creates an instance of this variable for all the calls of this function, and initializes only once.
    static EventManager instance;
    return instance;
}

void EventManager::listen(string event_name, EventListener *listener) {
    registeredEvents[tolower(event_name)].push_back(listener);
}

void EventManager::trigger(string event_name, void *args) {
    for (auto listener : registeredEvents[tolower(event_name)]) {
        listener->run(args);
    }
}

bool EventManager::is_running() {
    return running;
}

void EventManager::stop() {
    running = false;
}

void EventManager::check_events() {
    string buffer;
    vector<string> words;

    cout << "> ";               // print prompt
    getline(cin, buffer, '\n');    // read a line from cin to "buffer"
    buffer = tolower(buffer);

    string::size_type pos = 0, last_pos = 0;

    // Break "buffer" up by spaces
    bool finished = false;
    while (!finished) {
        pos = buffer.find_first_of(' ', last_pos);    // find and remember first space.
        if (pos == string::npos) {            // if we found the last word,
            words.push_back(buffer.substr(last_pos));    // add it to vector "words"
            finished = true;                // and finish searching.
        } else {                    // otherwise add to vector and move on to next word.
            words.push_back(buffer.substr(last_pos, pos - last_pos));
            last_pos = pos + 1;
        }
    }

    trigger("input", &words);
}

void EventManager::event_loop() {
    EventManager &eventManager = EventManager::getInstance();

    while (eventManager.is_running()) {
        eventManager.check_events();
    }
}

// InputListener.cpp
InputListener::InputListener(Game *game) {
    this->game = game;
}

void InputListener::run(void *args_ptr) {
    // Let's make this thing a bit safer by "translating" the pointer back to what we expect
    // This is exactly what makes this "void *" pointer dangerous.
    vector<string> *args = (vector<string> *) args_ptr;

    EventManager &eventManager = EventManager::getInstance();

    if (args->size() > 0) {
        // If arg[0] is "input", we are going to ignore the input.
        // If we do not ignore the input, it's an infinite loop.
        if (args->at(0) == "input") {
            return;
        }

        eventManager.trigger(args->at(0), args);

        if (eventManager.is_running()) {
            game->update_screen();
        }
    } else {
        eventManager.trigger("no_command", nullptr);
    }
}

// TeleportListener.cpp
TeleportListener::TeleportListener(Game *game) {
    this->game = game;
}

void TeleportListener::run(void *) {
    if (game->is_over()) {
        return;
    }

    this->game->teleport();
}

// RestartListener.cpp
RestartListener::RestartListener(Game *game) {
    this->game = game;
}

void RestartListener::run(void *) {
    game->reset(false);
}

// EnterRoomListener.cpp
EnterRoomListener::EnterRoomListener(Game *game) {
    this->game = game;
}

void EnterRoomListener::run(void *args) {
    if (game->is_over()) {
        return;
    }

    Room *room = (Room *) args;

    if (room->getName() == "J") {
        EventManager::getInstance().trigger("victory");
    }
}

// CharacterDeathListener.cpp
CharacterDeathListener::CharacterDeathListener(Game *game) {
    this->game = game;
}

void CharacterDeathListener::run(void *args) {
    if (game->is_over()) {
        return;
    }

    Character *character = (Character *) args;

    if (character->getName() == game->getPlayer().getName()) {
        EventManager::getInstance().trigger("defeat");
    }
}

// EnemyDeathListener.cpp
EnemyDeathListener::EnemyDeathListener(Game *game) {
    this->game = game;
}

void EnemyDeathListener::run(void *args) {
    if (game->is_over()) {
        return;
    }

    auto *enemy = (Enemy *) args;

    game->removeEnemy(enemy->getName());                    //remove enemy from game when health == 0;
    cout << "You killed the " + enemy->getName() << endl;
    delete enemy;
}

// GoListener.cpp
GoListener::GoListener(Game *game) {
    this->game = game;
    direction = "";
}

void GoListener::run(void *args_ptr) {
    if (game->is_over()) {
        return;
    }

    vector<string> *args = (vector<string> *) args_ptr;

    if (args->size() > 1) {
        game->go(args->at(1));
    } else {
        cout << "Need a direction!" << endl;
    }
}

// VictoryListener.cpp
VictoryListener::VictoryListener(Game *game) {
    this->game = game;
}

void VictoryListener::run(void *) {
    cout << endl;
    cout << "Victory!" << endl;
    game->setOver(true);
}

// DefeatListener.cpp
DefeatListener::DefeatListener(Game *game) {
    this->game = game;
}

void DefeatListener::run(void *) {
    cout << endl;
    cout << "Defeat!" << endl;
    game->setOver(true);
}

// MapListener.cpp
MapListener::MapListener(Game *game) {
    this->game = game;
}

void MapListener::run(void *) {
    game->map();
}

// InfoListener.cpp
InfoListener::InfoListener(Game *game) {
    this->game = game;
}

void InfoListener::run(void *) {
    game->info();
}

// ExitListener.cpp
ExitListener::ExitListener(Game *game) {
    this->game = game;
}

void ExitListener::run(void *) {
    EventManager::getInstance().stop();
}

// DamageListener.cpp
DamageListener::DamageListener(Game *game) {
    this->game = game;
}

void DamageListener::run(void *args) {
    if (game->is_over()) {
        return;
    }
    Item *item = (Item *) args;

    if (item->getName() == "skull") {
        game->getPlayer() - 75;                           //triggered if skull is picked up
        game->getPlayer().removeFromInventory("skull");
        cout << "Ouch! You feel the skull damage your soul." << endl;
    } else if (item->getName() == "potion") {
        game->getPlayer() + 20;                           //triggered if potion is picked up
        game->getPlayer().removeFromInventory("potion");
    }
}

// TakeListener.cpp
TakeListener::TakeListener(Game *game) {
    this->game = game;
}

void TakeListener::run(void *args_ptr) {
    if (game->is_over()) {
        return;
    }
    auto *args = (vector<string> *) args_ptr;

    if (args->size() > 1) {
        game->take(args->at(1));
    } else {
        cout << "That is not an item" << endl;
    }
}

// AttackListener.cpp
AttackListener::AttackListener(Game *game) {
    this->game = game;
}

void AttackListener::run(void *args_ptr) {
    if (game->is_over()) {
        return;
    }
    auto *args = (vector<string> *) args_ptr;

    if (args->size() > 1) {
        game->attack(args->at(1));
    } else {
        cout << "That is not an enemy" << endl;
    }
}

// ShowListener.cpp
ShowListener::ShowListener(Game *game) {
    this->game = game;
}

void ShowListener::run(void *args_ptr) {
    if (game->is_over()) {
        return;
    }
    auto *args = (vector<string> *) args_ptr;

    if (args->size() > 1) {
        game->show(args->at(1));
    }
}

// Character.cpp
/**************
 * 2. Inheritance (including virtual methods) and cascading constructors
 * Player inherits from Character
 * Enemy inherits from Character
 *
 * @param _name - Character name
 * @param _health - Character health
 * @param _stamina - Character stamina
 */

/*************
 * 9. Initializer List
 * @param _name - Character name
 * @param _health - Character health
 * @param _stamina - Character stamina
 */
Character::Character(string _name, int _health, int _stamina) : name(std::move(_name)), health(_health),
                                                                       stamina(_stamina) {}

/**********
 * 1. Destructors
 */
Character::~Character() { std::cout << "Character destroyed"; }

string Character::getName() const { return name; }

int Character::getHealth() const { return health; }

int Character::getStamina() const { return stamina; }

Room *Character::getCurrentRoom() { return currentRoom; }

void Character::setCurrentRoom(Room *next) { currentRoom = next; }

/**********
 * 5. Binary operator overloading
 * @return - ostream of Character stats
 */
ostream &operator<<(ostream &os, const Character &character) {
    Enemy *ptr;
    os << character.name << " HP: " << character.health << " " << character.name << " SP: " << character.stamina << "\n";
    return os;
}

/********
 * 4. Unary operator overloading
 * @param _health - Character health to be increased by this amount
 */
void Character::operator-(int _health) {
    setHealth(health - _health);
}

/*********
 * 4. Unary operator overlaoding
 * @param _health - Character health to be increased by this amount
 */
void Character::operator+(int _health) {
    setHealth(health + _health);
}

/**********
 * 9. Initializer List
 * @param name - Player name
 */
Player::Player(const string &name) : Character(name, health, stamina) {
    // We need to use "this->" to differentiate between the "name" argument and the "name" from the class.
    health = 100;
    stamina = 100;
    currentRoom = nullptr;
}

/*********
 * 1. Destructors
 * Destroys Player object when out of scope
 */
Player::~Player() { std::cout << "\n Player defeated \n"; }

void Player::setStamina(int _stamina) {
    if (_stamina <= 0) {
        stamina = 0;
        EventManager::getInstance().trigger("characterDeath", this);
    }
    stamina = _stamina;
}

void Player::setHealth(int _health) {
    if (_health <= 0) {
        health = 0;
        EventManager::getInstance().trigger("characterDeath", this);
    }
    health = _health;
}

/**********
 * 6. Friends (Player is friend of Room to access itemsInRoom vector)
 * @param itemName - name of item to be added to players inventory
 */
void Player::addToInventory(const string &itemName) {
    Room *room = getCurrentRoom();
    for (auto &i : room->itemsInRoom) {
        if (i->getName() == itemName) {
            Inventory.push_back(i);
            break;
        }
    }

}

void Player::removeFromInventory(const string &itemName) {
    for (int i = 0; i < Inventory.size(); i++) {
        if (Inventory[i]->getName() == itemName) {
            Inventory.erase(Inventory.begin() + i);
            delete Inventory[i];
            break;
        }
    }
}

Item* Player::getInventoryItem(const string &itemName) {
    for(auto & i : Inventory) {
        if(i->getName() == itemName) {
            return i;
        }
    }
    return nullptr;
}

string Player::displayInventory() {
    string tempString = "Inventory: ";
    for (auto &i : Inventory) {
        tempString += i->getName() + ", ";
    }
    return tempString;
}

bool Player::itemInInventory(const string &itemName) {
    if (Inventory.empty()) {
        return false;
    } else {
        for (auto &i : Inventory) {
            if (itemName == i->getName()) {
                return true;
            }
        }
    }
    return false;
}

/***********
 * 9. Initializer List
 * @param name - Enemy name
 * @param health - Enemy health
 * @param stamina - Enemy stamina
 * @param _roaming - Boolean if enemy can move or not
 */
Enemy::Enemy(const string &name, int health, int stamina, bool _roaming) : Character(name, health, stamina),
                                                                           roaming(_roaming) {}
/***********
 * 1. Destructors
 */
Enemy::~Enemy() {
    std::cout << "\n Enemy defeated \n";
}

void Enemy::setStamina(int _stamina) {
    if (_stamina <= 0) {
        stamina = 0;
        EventManager::getInstance().trigger("enemyDeath", this);
    }
    stamina = _stamina;
}

void Enemy::setHealth(int _health) {
    if (_health <= 0) {
        health = 0;
        EventManager::getInstance().trigger("enemyDeath", this);
    }
    health = _health;
}

bool Enemy::roamingCheck() const {
    return roaming;
}

void Enemy::Move(Enemy *enemy) {
    vector<string> directions{"north", "east", "south", "west"};
    Room *next;
    unsigned seed = std::chrono::system_clock::now().time_since_epoch().count();       //create time based seed for shuffle

    std::shuffle(directions.begin(), directions.end(), std::default_random_engine(seed));   //shuffle directions
    for (auto &direction : directions) {
        next = enemy->getCurrentRoom()->getExit(direction);
        if (next != nullptr) {                                   //check exit isn't dead end
            if (!next->lockCheck()) {                            //check exit isn't locked
                enemy->setCurrentRoom(next);                    //move if satisfies
                break;
            }
        }
    }
}

// Room.cpp
Room::Room(string name) :
        name(name) {
    exits["north"] = nullptr;
    exits["east"] = nullptr;
    exits["south"] = nullptr;
    exits["west"] = nullptr;
}

Room::Room(string name, bool isLocked) :
        name(name) {
    exits["north"] = nullptr;
    exits["east"] = nullptr;
    exits["south"] = nullptr;
    exits["west"] = nullptr;
    this->isLocked = isLocked;
}

string Room::getName() {
    return name;
}

void Room::setName(string name) {
    this->name = name;
}

bool Room::lockCheck() {
    return isLocked;
}

bool Room::unlock() {
    return isLocked = false;
}


void Room::setExits(Room *north, Room *east, Room *south, Room *west) {
    exits["north"] = north;
    exits["east"] = east;
    exits["south"] = south;
    exits["west"] = west;
}

void Room::addItem(Item *newItem) {
    itemsInRoom.push_back(newItem);
}

void Room::removeItem(string itemName) {
    for (int i = 0; i < itemsInRoom.size(); i++) {
        if (itemsInRoom[i]->getName() == itemName) {
            itemsInRoom.erase(itemsInRoom.begin() + i);         //erase item at point i
            break;
        }
    }
}

Room *Room::getExit(string direction) {
    return exits[direction];
}

Item* Room::getItem(string itemName) {
    string description;
    for (auto & i : itemsInRoom) {
        if (i->getName() == itemName) {
            return i;
        }
    }
    return nullptr;
}

bool Room::isItemInRoom(string itemName) {
    if (itemsInRoom.empty()) {
        return false;
    } else {
        for (auto &i : itemsInRoom) {
            if (itemName == i->getName()) {   //loop to check if item is in vector
                return true;
            }
        }

    }
    return false;
}

string Room::displayItem() {
    string tempString = "Items in room: ";
    if (itemsInRoom.empty()) {
        tempString = "There are no items in this room";
    } else {
        for (auto &i : itemsInRoom) {
            tempString += i->getName() + ", ";
        }
    }
    return tempString;
}

// Item.cpp

/*************
 * Initializer List
 * @param name - Name of item
 * @param description - Short description of item
 */
Item::Item(string name, string description, int value) : name(std::move(name)), description(std::move(description)), value(value) {}

/***********
 * 1. Destructors
 * Destroy item when out of scope
 */
Item::~Item() {

    std::cout << "\n Item deleted \n";
}

string Item::getName() { return name;}


string Item::getDescription() {
    return description;
}

int Item::getValue() const { return value; }

Weapon::Weapon(string name, string description, int value) : Item(std::move(name), std::move(description), (value)) {}

Weapon::~Weapon() {
    std::cout << "\n Weapon deleted \n";
}

/*******
 * 7. Virtual Functions & Polymorphism
 * @return
 */
string Weapon::getDescription() {
    if (getValue() >= 30 && getValue() < 100) {
        description += " This weapon is rare";
    } else if (getValue() >= 100) {
        description += " Whoa! This weapon is very rare";
    }
    return description;
}

// Game.cpp
Game::Game() :

        player("Hero") {
    srand(time(nullptr));

    // Commands
    EventManager::getInstance().listen("go", new GoListener(this));
    EventManager::getInstance().listen("map", new MapListener(this));
    EventManager::getInstance().listen("info", new InfoListener(this));
    EventManager::getInstance().listen("restart", new RestartListener(this));
    EventManager::getInstance().listen("teleport", new TeleportListener(this));
    EventManager::getInstance().listen("exit", new ExitListener(this));
    EventManager::getInstance().listen("take", new TakeListener(this));
    EventManager::getInstance().listen("attack", new AttackListener(this));
    EventManager::getInstance().listen("show", new ShowListener(this));

    // State changes
    EventManager::getInstance().listen("characterDeath", new CharacterDeathListener(this));
    EventManager::getInstance().listen("enemyDeath", new EnemyDeathListener(this));
    EventManager::getInstance().listen("enterRoom", new EnterRoomListener(this));
    EventManager::getInstance().listen("victory", new VictoryListener(this));
    EventManager::getInstance().listen("defeat", new DefeatListener(this));
    EventManager::getInstance().listen("damage", new DamageListener(this));

    rooms.push_back(new Room("A")); // 0
    rooms.push_back(new Room("B")); // 1
    rooms.push_back(new Room("C")); // 2
    rooms.push_back(new Room("D")); // 3
    rooms.push_back(new Room("E")); // 4
    rooms.push_back(new Room("F")); // 5
    rooms.push_back(new Room("G")); // 6
    rooms.push_back(new Room("H")); // 7
    rooms.push_back(new Room("I")); // 8
    rooms.push_back(new Room("J", true)); // 9

    /***
     * 10. Dynamic & Static Dispatch
     */
    Item *dagger = new Weapon("dagger", "It's not very sharp, but it'll do the trick.", 30);
    Item *longsword = new Weapon("longsword", "A sharp dangerous sword. Now we're talking!", 100);
    rooms[0]->addItem(new Item("potion", "A strange elixir. You feel stronger than ever!", 10));
    rooms[4]->addItem(new Item("skull", "Very freaky looking thing", 20));
    rooms[6]->addItem(new Item("key", "Oh a key. This might be useful on my adventure", 10));
    rooms[5]->addItem(dagger);
    rooms[3]->addItem(longsword);

    enemies.push_back(new Enemy("dragon", 250, 80, false));  //0
    enemies.push_back(new Enemy("goblin", 150, 50, true));  //1

    //                 N                E               S               W
    rooms[0]->setExits(rooms[4], rooms[2], rooms[7], rooms[1]);
    rooms[1]->setExits(nullptr, rooms[0], nullptr, nullptr);
    rooms[2]->setExits(nullptr, nullptr, nullptr, rooms[0]);
    rooms[3]->setExits(nullptr, rooms[4], nullptr, nullptr);
    rooms[4]->setExits(nullptr, rooms[5], rooms[0], rooms[3]);
    rooms[5]->setExits(nullptr, nullptr, nullptr, rooms[4]);
    rooms[6]->setExits(nullptr, rooms[7], nullptr, nullptr);
    rooms[7]->setExits(rooms[0], rooms[8], rooms[9], rooms[6]);
    rooms[8]->setExits(nullptr, nullptr, nullptr, rooms[7]);
    rooms[9]->setExits(rooms[7], nullptr, nullptr, nullptr);


    reset();
}

/**
 * 3. Templates - Print out user specified object names
 * @tparam obj - Object type to be passed
 * @param vec - Vector of type "object" name
 * @return
 */
template<class obj>
string Game::printVector(vector<obj> vec) {
    for (int i = 0; i < vec.size(); i++) {
        obj object = vec[i];
        cout << object->getName() << endl;
    }
    string temp = "No objects";
    return temp;
}

void Game::reset(bool show_update) {
    gameOver = false;

    player.setCurrentRoom(rooms[0]);
    player.setHealth(100);
    player.setStamina(100);

    enemies[0]->setCurrentRoom(rooms[8]);
    enemies[1]->setCurrentRoom(rooms[3]);

    cout << "Welcome to Zork!" << endl;

    if (show_update) {
        update_screen();
    }
}

void Game::setOver(bool over) {
    this->gameOver = over;
}

void Game::mapUpdate() {
    string names[] = {"A", "B", "C", "D", "E", "F", "G", "H", "I", "J"};

    for (int i = 0; i < rooms.size(); i++) {
        for (int j = 0; j < enemies.size(); j++) {
            if (player.getCurrentRoom() == rooms[i] && enemies[j]->getCurrentRoom() != rooms[i]) {
                rooms[i]->setName("[" + names[i] + "]");               //add [] to players current room
            } else if (enemies[j]->getCurrentRoom() == rooms[i] && player.getCurrentRoom() != rooms[i]) {
                rooms[i]->setName("!" + names[i] + "!");    //add !! to enemies current room
                j++;
            } else if (enemies[j]->getCurrentRoom() == rooms[i] && player.getCurrentRoom() == rooms[i]) {
                rooms[i]->setName("![" + names[i] + "]!");   //add ![]! to room with both enemies and player
                j++;
            } else {
                rooms[i]->setName(names[i]);
            }
        }
        if (enemies.empty() && player.getCurrentRoom() == rooms[i]) {
            rooms[i]->setName("[" + names[i] + "]");
        }
    }
}

void Game::map() {
    cout << rooms[3]->getName() << "--- " << rooms[4]->getName() << "---- " << rooms[5]->getName() << endl;
    cout << "      |" << endl;
    cout << rooms[1]->getName() << "--- " << rooms[0]->getName() << "---- " << rooms[2]->getName() << endl;
    cout << "      |" << endl;
    cout << " " << rooms[6]->getName() << "--- " << rooms[7]->getName() << "---- " << rooms[8]->getName() << endl;
    cout << "      |" << endl;
    cout << "      " << rooms[9]->getName() << endl;

    /*cout << "   -------                -------                 ------- " << endl;
    cout << "     |  D  |----------------|  E  |-----------------|  F  | " << endl;
    cout << "     -------                -------                 ------- " << endl;
    cout << "                               |                            " << endl;
    cout << "                               |                            " << endl;
    cout << "                               |                            " << endl;
    cout << "     -------                -------                 ------- " << endl;
    cout << "     |  B  |----------------|  A  |-----------------|  C  | " << endl;
    cout << "     -------                -------                 ------- " << endl;
    cout << "                               |                            " << endl;
    cout << "                               |                            " << endl;
    cout << "                               |                            " << endl;
    cout << "     -------                -------                 ------- " << endl;
    cout << "     |  G  |----------------|  H  |-----------------|  I  | " << endl;
    cout << "     -------                -------                 ------- " << endl;
    cout << "                               |                            " << endl;
    cout << "                               |                            " << endl;
    cout << "                               |                            " << endl;
    cout << "                            -------                         " << endl;
    cout << "                            |  J  |                         " << endl;
    cout << "                            -------                         " << endl;

    cout << "D-E-F" << endl;
    cout << "B-A-C" << endl;
    cout << "  |  " << endl;
    cout << "G-H-I" << endl;
    cout << "  |  " << endl;
    cout << "  J  " << endl;
     */
}

void Game::info() {
    cout << "Available commands:" << endl;
    cout << " - go <direction>" << endl;
    cout << " - teleport" << endl;
    cout << " - take <item>" << endl;
    cout << " - attack <enemy>" << endl;
    cout << " - map" << endl;
    cout << " - show" << endl;
    cout << " - info" << endl;
}

void Game::go(string direction) {
    Room *next = player.getCurrentRoom()->getExit(direction);

    if (next != nullptr) {
        if (!next->lockCheck()) {        //check for no lock on door
            player.setCurrentRoom(next);
            player.setStamina(player.getStamina() - 1);
            EventManager::getInstance().trigger("enterRoom", next);
            for (auto enemy : enemies) {
                if (enemy->roamingCheck()) {        //check if enemy can roam
                    enemy->Move(enemy);
                    enemy->setStamina(enemy->getStamina() - 1);
                }
            }
        } else {
            if (player.itemInInventory("key")) {     //check for possession of key
                cout << "This door is locked but you have a key! Hooray!" << endl;
                cout << "Unlocking door..." << endl;
                next->unlock();                     //unlock door if key in inventory
                player.setCurrentRoom(next);
                player.removeFromInventory("key");
                EventManager::getInstance().trigger("enterRoom", next);
            } else {
                cout << "The room is locked and you have not got a key" << endl;
            }
        }
    } else {
        cout << "You hit a wall" << endl;
    }
}

void Game::teleport() {
    int selected = rand() % rooms.size();
    player.setCurrentRoom(rooms[selected]);
    player.setStamina(player.getStamina() - 50);
    EventManager::getInstance().trigger("enterRoom", rooms[selected]);
}

void Game::take(const string& itemName) {
    bool isThere = player.getCurrentRoom()->isItemInRoom(itemName);
    if (!isThere) {      //check if item is in room
        cout << "item is not in room";
    } else {
        player.addToInventory(itemName);
        cout << "You have taken " + itemName << endl;
        cout << player.getCurrentRoom()->getItem(itemName)->getDescription() << endl;
        player.getCurrentRoom()->removeItem(itemName);
        EventManager::getInstance().trigger("damage", player.getInventoryItem(itemName));  //triggers damage event
    }
}

void Game::attack(const string &enemyName) {
    for (auto &enemy : enemies) {
        if (player.getCurrentRoom() == enemy->getCurrentRoom() && enemyName == enemy->getName() &&
            player.itemInInventory("longsword")) {
            cout << "You slash the " + enemyName + " with your mighty longsword!" << endl;
            enemy->operator-(player.getInventoryItem("longsword")->getValue());
        }else if(player.getCurrentRoom() == enemy->getCurrentRoom() && enemyName == enemy->getName() &&
                 player.itemInInventory("dagger")) {
            cout << "You pathetically poke the " + enemyName + " with your dagger!" << endl;
            enemy->operator-(player.getInventoryItem("dagger")->getValue());
        }else if(player.getCurrentRoom() == enemy->getCurrentRoom() && enemyName == enemy->getName()) {
            cout << "You attack the " + enemyName + " with a mighty fist!" << endl;
            enemy->operator-(10);
        }
    }
}

bool Game::is_over() {
    return gameOver;
}

Player &Game::getPlayer() {
    return player;
}

void Game::removeEnemy(const string &enemyName) {
    for (int i = 0; i < enemies.size(); i++) {
        if (enemyName == enemies[i]->getName()) {
            enemies.erase(enemies.begin() + i);
        }
    }
}

void Game::show(const string &objects) {
    if (objects == "enemies") {
        printVector(enemies);
    } else if (objects == "rooms") {
        printVector(rooms);
    } else {
        cout << "Incorrect entry!" << endl;
    }
}

void Game::update_screen() {
    if (!gameOver) {
        mapUpdate();
        Room *currentRoom = player.getCurrentRoom();

        cout << endl;
        cout << "You are in " << currentRoom->getName() << endl;
        cout << currentRoom->displayItem() << endl;
        cout << player.displayInventory() << endl;
        string tempString = "Enemies in room: ";
        for (auto &i : enemies) {
            if (player.getCurrentRoom() == i->getCurrentRoom()) {
                cout << tempString + i->getName() << endl;
            }
        }

        cout << "Exits:";
        if (currentRoom->getExit("north") != nullptr) { cout << " north"; }
        if (currentRoom->getExit("east") != nullptr) { cout << " east"; }
        if (currentRoom->getExit("south") != nullptr) { cout << " south"; }
        if (currentRoom->getExit("west") != nullptr) { cout << " west"; }
        cout << endl;
        cout << player;
        for (auto &enemy : enemies) {
            if (currentRoom == enemy->getCurrentRoom()) {
                cout << enemy->getName() << " HP: " << enemy->getHealth() << " "
                     << enemy->getName() << " SP: " << enemy->getStamina() << endl;
            }
        }
    } else {
        cout << R"(Type "restart" or "exit".)" << endl;
    }
}


// main.cpp
int main() {
    Game game;
    EventManager::getInstance().listen("input", new InputListener(&game));
    EventManager::getInstance().event_loop();
    return EXIT_SUCCESS;
}
